
<section class="section">

  {{#if user}}
  <!--
  <canvas id="taicanvas" width="800" height="600"></canvas>
  <canvas class="right" id="taibox" width="200" height="600"></canvas>

-->
<script
			  src="https://code.jquery.com/jquery-3.5.1.js"
			  integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc="
			  crossorigin="anonymous"></script>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>






<link rel="stylesheet" href="/stylesheets/style.css">
<script src="./javascripts/taidata.js"></script>

<script type="text/javascript">
var body = document.body,
    overlay = document.querySelector('.overlay'),
    overlayBtts = document.querySelectorAll('button[class$="overlay"]');

[].forEach.call(overlayBtts, function(btt) {

  btt.addEventListener('click', function() {

     /* Detect the button class name */
     var overlayOpen = this.className === 'open-overlay';

     /* Toggle the aria-hidden state on the overlay and the
        no-scroll class on the body */
     overlay.setAttribute('aria-hidden', !overlayOpen);
     body.classList.toggle('noscroll', overlayOpen);

     /* On some mobile browser when the overlay was previously
        opened and scrolled, if you open it again it doesn't
        reset its scrollTop property */
     overlay.scrollTop = 0;

  }, false);

});




//  owner:null,
//  space:"none",
RecRooms=0;

var SelectedPiece=null;

var localPlayer;

var revPX=function(p) {
  z=p.worldX;


  var x=Math.floor((4350-z)/100)
return x;



}
var getPX=function(dat) {
var str=dat.tile.split(";")
var x =parseInt(str[1] , 10)

return 4300-100*x

}


var revPY=function(p) {
  z=p.worldY;
var x=Math.floor((z+100)/100)
var str;
if(x==1) {
  str="a"
} else if(x==2) {
  str="b"
}
else if(x==3) {
  str="c"
}

else if(x==4) {
  str="d"
}

else if(x==5) {
  str="e"
}

else if(x==6) {
  str="f"
}

else if(x==7) {
  str="g"
}

else if(x==8) {
  str="h"
}
else if(x==9) {
  str="i"
}
else if(x==10) {
  str="j"
}
else if(x==11) {
  str="k"
}
else if(x==12) {
  str="l"
}
else if(x==13) {
  str="m"
}
else if(x==14) {
  str="n"
}
else if(x==15) {
  str="o"
}
else if(x==16) {
  str="p"
}
else if(x==17) {
  str="q"
}
else if(x==18) {
  str="r"
}
else if(x==19) {
  str="s"
}
else if(x==20) {
  str="t"
}
else if(x==21) {
  str="u"
}
else if(x==22) {
  str="v"
}
else if(x==23) {
  str="w"
}
else if(x==24) {
  str="x"
}
else if(x==25) {
  str="y"
}
else if(x==26) {
  str="z"
}
else if(x==27) {
  str="aa"
}
else if(x==28) {
  str="bb"
}
else if(x==29) {
  str="cc"
}
else if(x==30) {
  str="dd"
}
else if(x==31) {
  str="ee"
}
else if(x==32) {
  str="ff"
}
else if(x==33) {
  str="gg"
}
else if(x==34) {
  str="hh"
}
else if(x==35) {
  str="ii"
}
else if(x==36) {
  str="jj"
}




return str;

}

var getPY=function(dat) {
x=0
var str=dat.tile.split(";")
if(str[0]=="a") {
x=1
}
else if (str[0]=="b") {
x=2
}
else if (str[0]=="c") {
x=3
}
else if (str[0]=="d") {
x=4
}else if (str[0]=="e") {
x=5
}else if (str[0]=="f") {
x=6
}else if (str[0]=="g") {
x=7
}else if (str[0]=="h") {
x=8
}else if (str[0]=="i") {
x=9
}else if (str[0]=="j") {
x=10
}else if (str[0]=="k") {
x=11
}else if (str[0]=="l") {
x=12
}else if (str[0]=="m") {
x=13
}else if (str[0]=="n") {
x=14
}else if (str[0]=="o") {
x=15
}else if (str[0]=="p") {
x=16
}else if (str[0]=="q") {
x=17
}else if (str[0]=="r") {
x=18
}else if (str[0]=="s") {
x=19
}else if (str[0]=="t") {
x=20
}else if (str[0]=="u") {
x=21
}else if (str[0]=="v") {
x=22
}else if (str[0]=="w") {
x=23
}else if (str[0]=="x") {
x=24
}else if (str[0]=="y") {
x=25
}else if (str[0]=="z") {
x=26
}else if (str[0]=="aa") {
x=27
}else if (str[0]=="bb") {
x=28
}else if (str[0]=="cc") {
x=29
}else if (str[0]=="dd") {
x=30
}else if (str[0]=="ee") {
x=31
}else if (str[0]=="ff") {
x=32
}else if (str[0]=="gg") {
x=33
}else if (str[0]=="hh") {
x=34
}else if (str[0]=="ii") {
x=35
}else if (str[0]=="jj") {
x=36
}



return 100*x-50;

}
onObjectClicked=function(pointer,object)
    {
      console.log(object);

      if(object.isTilemap) {
        locationP=revPY(pointer)+";"+revPX(pointer)
        socket.emit('makeMove', { location: locationP,piece:SelectedPiece.parRef.dat.pUUID ,room: gameN.id,player:  localPlayer});
        SelectedPiece=null;
          layer.removeInteractive()
      } else {
      let objectName = object.texture.key;

        if(objectName === "piece") {
      if (SelectedPiece==null) {
      SelectedPiece=object
      layer.setInteractive({ useHandCursor: true })
    } else {

      locationP=revPY(pointer)+";"+revPX(pointer)
      socket.emit('makeMove', { location: locationP,piece:SelectedPiece.parRef.dat.pUUID ,room: gameN.id,player:  localPlayer});
      SelectedPiece=null;


    }
    }

    if(objectName === "") {

    }
  }

    }



var makePiece=function(dat,p) {
var piece={}
piece.dat=dat

piece.x=getPX(dat)
piece.y=getPY(dat)
piece.dx=piece.x
piece.dy=piece.y
piece.sprite=p.add.sprite( piece.dx,piece.dy, 'piece');
piece.sprite.parRef=piece;
piece.sprite.setInteractive({ useHandCursor: true })


if(dat.owner=="p2") {
  piece.sprite.flipY=true;
}

var SelectBox;
var textConfig={fontSize:'40px',color:'#ffff00',fontFamily: 'Arial'};
piece.text = p.add.text(piece.dx-(40-(25*dat.pID.length)),piece.dy-25,dat.pID.toUpperCase(),textConfig);
return piece.sprite;




}
/*
var locationz=""
if(window.location.hostname.includes("localhost")) {
  locationz='http://localhost:3001'
} else {
  locationz=window.location.hostname
}
*/
var layer =null
var tiles =null;
var taiSocket=0
var gameState={};
var pieceSprites;
jQuery(function ($) {
$( document ).ready(function() {



taiSocket=socket;
var cam=null
var input=null;
input=null;
loaded=false
var Preload = new Phaser.Class({
Extends: Phaser.Scene,

  initialize:
  function GameScene ()
   {
       Phaser.Scene.call(this, { key: 'Preload', active: true });


   },
    preload:function () {

  },

    create:function(){




    },

    update:function() {

      if(!loaded) {

        if(gameN!=null) {

          if(gameN.gamestate!=null) {

            loaded=true;

            if(gameN.players["p1"]!=null) {
            if(gameN.players["p1"].name=="{{user.username}}"){
              localPlayer="p1"
            }
          }
            if(gameN.players["p2"]!=null) {
            if(gameN.players["p2"].name=="{{user.username}}"){
              localPlayer="p2"
            }
          }
            $('#startGameNow').trigger('click')

            this.scene.start('gameScene');
          }


        }
      }

    }


})
var createRoom=function(roomNAME) {
  var txt = $('#roomtxt').val();
    if (/\S/.test(txt)) {

socket.emit('createRoom', { roomName: txt, username: "{{user.username}}",game:"taikyoku" });
  $('#roomtxt').val("");
  $('#startGameNow').trigger('click')
}
}

var joinClick=function(txt) {

socket.emit('joinRoom', { roomName: txt, username: "{{user.username}}", game:"taikyoku"});
  $('#roomtxt').val("");
  $('#startGameNow').trigger('click')

}

var joinRoom=function() {
  var txt = $('#roomtxt').val();
socket.emit('joinRoom', { roomName: txt, username: "{{user.username}}", game:"taikyoku"});
  $('#roomtxt').val("");
  $('#startGameNow').trigger('click')

}

$('#create').click(function(){

  createRoom();
})

$('#joinC').click(function(){

  joinClick($(this).attr("value"));
})



$('#join').click(function(){

  joinRoom();
})


var GameScene = new Phaser.Class({


Extends: Phaser.Scene,

initialize:

function GameScene ()
 {

     Phaser.Scene.call(this, { key: 'gameScene', active: false });


 },

preload:function ()
{
  this.load.image('tile','images/taikyoku/tile.png');
  this.load.image('piece','images/taikyoku/piece.png');
  this.load.image('select','images/taikyoku/select.png');
  this.load.tilemapTiledJSON('map', 'javascripts/board.json');
  if (this.game.canvas!=null) {
  this.game.canvas.id = 'game';
  }






},

create:function ()
{
  //this.add.image(400, 300, 'sky');
  var map = this.make.tilemap({ key: 'map' });
   tiles = map.addTilesetImage('tile', 'tile');
   layer = map.createStaticLayer(0, tiles, 650, 0);



input=this.input;
input.on('gameobjectdown',onObjectClicked);
var textConfig={fontSize:'80px',color:'#ffffff',fontFamily: 'Arial'};
if(gameN.players[gameN.gamestate.turnOwner]!=null) {
turntext = this.add.text(-575,-200, gameN.players[gameN.gamestate.turnOwner].name+"'s turn.",textConfig).setScrollFactor(0);
} else {
turntext = this.add.text(-575,-200, "undefined's turn.",textConfig).setScrollFactor(0);
}

//  this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels+2050);
  this.cameras.main.zoom =0.5;
  this.cameras.main.scrollX=1250;

  var cursors =  this.input.keyboard.createCursorKeys();
  var particles = this.add.particles('red');
  var controlConfig = {

      camera: this.cameras.main,

      zoomIn: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
      zoomOut: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
      left: cursors.left,
      right: cursors.right,
      up: cursors.up,
      down: cursors.down,
      speed: 1,
      acceleration: 0.06,
drag: 0.0005,
maxSpeed: 1.0
  };

  var pieces=   0;
  pieceSprites={}

  cam = this.cameras.main;


     gui = new dat.GUI( { autoPlace: false });
     gui.domElement.id = 'gui';

     var help = {
         line1: 'Cursors to move',
         line2: 'Q & E to zoom'
     }

     var f1 = gui.addFolder('Camera');
     f1.add(cam, 'x').listen();
     f1.add(cam, 'y').listen();
     f1.add(cam, 'scrollX').listen();
     f1.add(cam, 'scrollY').listen();

     f1.add(cam, 'zoom', 0.2, 2).step(0.1).listen();
     //f1.add(help, 'line1');
    // f1.add(help, 'line2');
     //f1.open();

  for(var key in gameN.gamestate.board) {
  var p= gameN.gamestate.board[key];
if(p!=null) {
  pieceSprites[key]  = makePiece(p,this);


  }

}
SelectBox=this.add.sprite( -4000,-4000, 'select');





  controls = new Phaser.Cameras.Controls.FixedKeyControl(controlConfig);
/*
  var emitter = particles.createEmitter({
      speed: 100,
      scale: { start: 1, end: 0 },
      blendMode: 'ADD'
  });
*/
//  var logo = this.physics.add.image(400, 100, 'logo');

  //logo.setVelocity(100, 200);
  //logo.setBounce(1, 1);
  //logo.setCollideWorldBounds(true);

  //emitter.startFollow(logo);
    $("#userMessage").focus(function(){
input.keyboard.enabled=false
  input.keyboard.clearCaptures()
    });
  $("#game").mouseenter(function() {


              //
                  console.log(input.keyboard)
                  input.keyboard.addCapture('LEFT,RIGHT,UP,DOWN,Q,E');

                  input.keyboard.enabled=true;



          });

          $("#game").mouseleave(function() {

            input.keyboard.enabled=false;

           input.keyboard.clearCaptures()


          });
},


update:function(time, delta) {
  if(gameN.players["p1"]!=null) {
  if(gameN.players["p1"].name=="{{user.username}}"){
    localPlayer="p1"
  }
}
  if(gameN.players["p2"]!=null) {
  if(gameN.players["p2"].name=="{{user.username}}"){
    localPlayer="p2"
  }
}
  this.cameras.main.setZoom(Phaser.Math.Clamp(this.cameras.main.zoom, 0.2, 1));﻿
    this.cameras.main.scrollX=Phaser.Math.Clamp(this.cameras.main.scrollX, 0, 3400)

    this.cameras.main.scrollY=  Phaser.Math.Clamp(this.cameras.main.scrollY, 0, 2850);

if(gameN!=null) {
  if(gameN.players[gameN.gamestate.turnOwner]!=null) {
  turntext.text= gameN.players[gameN.gamestate.turnOwner].name+"'s turn."
}

  for(var key in pieceSprites) {
  var p= pieceSprites[key];

  if(gameN.gamestate.board[key]!=null) {

  p.parRef.x=getPX(gameN.gamestate.board[key])
  p.parRef.y=getPY(gameN.gamestate.board[key])
} else {
  pieceSprites[key].parRef.text.destroy()
  pieceSprites[key].destroy()

  delete pieceSprites[key];
}

}

for(var key in pieceSprites) {

var p= pieceSprites[key];
if(p.parRef.x>p.parRef.dx) {
p.parRef.dx+=10;
p.parRef.dx=Phaser.Math.Clamp(p.parRef.dx,p.parRef.dx,p.parRef.x)


}

if(p.parRef.x<p.parRef.dx) {
p.parRef.dx-=10;
p.parRef.dx=Phaser.Math.Clamp(p.parRef.dx,p.parRef.x,p.parRef.dx)


}
if(p.parRef.y>p.parRef.dy) {
p.parRef.dy+=10;
p.parRef.dy=Phaser.Math.Clamp(p.parRef.dy,p.parRef.dy,p.parRef.y)


}
if(p.parRef.y<p.parRef.dy) {
p.parRef.dy-=10;
p.parRef.dy=Phaser.Math.Clamp(p.parRef.dy,p.parRef.y,p.parRef.dy)


}
p.parRef.text.x= p.parRef.dx-(40-(25*p.parRef.text._text.length))
p.parRef.text.y=p.parRef.dy-25

p.x=p.parRef.dx;
p.y=p.parRef.dy;
}



  if(SelectedPiece!=null) {
    SelectBox.x=SelectedPiece.x;
    SelectBox.y=SelectedPiece.y;
    if(SelectedPiece.parRef.dat.owner=="p2") {
      SelectBox.flipY=true;
    } else {
      SelectBox.flipY=false;
    }
  } else {
    SelectBox.x=-4000
    SelectBox.y=-4000
  }
pieces=       gameN.gamestate.board;
}

controls.update(delta);





}


})


var config = {
  type: Phaser.CANVAS,
  height:600,
  width:1200,
  parent:document.getElementById("gameCanvasDiv"),
  physics: {
      default: 'arcade',
      arcade: {
          gravity: { y: 200 }
      }
  },
  scene:[Preload,GameScene]
};


var game = new Phaser.Game(config);


});
})









</script>
<!--<script type="module" type="text/javascript"  src='./javascripts/imports.js'></script> -->



<div class="container absH" id="theGame">

  <ul class="nav nav-tabs">
    <li ><a data-toggle="tab" id="startGameNow" href="#game">Game</a></li>
    <li class="active"><a class="active" data-toggle="tab" href="#menu1g" aria-expanded="true">Menu 1</a></li>
    <li><a data-toggle="tab" href="#menu2g">Menu 2</a></li>

  </ul>

  <div class="tab-content">
    <div id="game" class="tab-pane fade">

<div id="gameCanvasDiv"></div>




</div>
<div id="menu1g" class="tab-pane fade in active show">
  {{#unless (inGame user.roomlock) }}
  <h3>RoomList</h3>
  <div class="input-group mb-3">
     <input type="text" class="form-control" placeholder="Room" id="roomtxt" />
    <div class="input-group-append">
<button id ="create" type="button" class="input-group-append btn btn-success right">Create</button>

   <button  id ="join" type="button" class="input-group-append btn btn-success right">Join</button>
</div>


</div>

<button class="input-group-append btn btn-success" onClick="window.location.reload();">Refresh</button>
<hr>
<div class="container">


{{#each (rooms)}}
<div>
Room name:  {{roomname}}  id: {{id}} <button id= "joinC" class="input-group-append btn btn-success" value="{{id}}">Join</button>
</div>

{{/each}}



</div>

{{/unless}}
{{#if (inGame user.roomlock) }}
<h1> Can't view rooms while ingame</h1>
{{/if}}



</div>
<div id="menu2g" class="tab-pane fade">
  <h3>Menu 2</h3>
  <p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam.</p>
</div>

</div>
</div>
  {{/if}}
  {{#unless user}}
  You must be logged in to play
  {{/unless}}


</section>
